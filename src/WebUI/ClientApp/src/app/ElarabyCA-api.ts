/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IElarabyClient {
    workOrders(): Observable<FileResponse>;
    getWorkOrderById(id: string | null): Observable<FileResponse>;
    create(model: CreateOrderViewModel): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ElarabyClient implements IElarabyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    workOrders(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Elaraby/WorkOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkOrders(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processWorkOrders(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getWorkOrderById(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Elaraby/GetWorkOrderById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderById(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    create(model: CreateOrderViewModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Elaraby/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IOrderClient {
    patch(patchData: PatchOrderEdit): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    query(filter: FilterContainer): Observable<FileResponse>;
    create(model: CreateOrderViewModel): Observable<FileResponse>;
    update(id: number | undefined, model: CreateOrderViewModel): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrderClient implements IOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    patch(patchData: PatchOrderEdit): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Order/Patch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Order/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    query(filter: FilterContainer): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Order/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    create(model: CreateOrderViewModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Order/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number | undefined, model: CreateOrderViewModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Order/Update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IOrderTicketClient {
    create(model: OrderTicket): Observable<FileResponse>;
    update(id: number | undefined, model: OrderTicket): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    query(filter: FilterContainer): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrderTicketClient implements IOrderTicketClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(model: OrderTicket): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/OrderTicket/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number | undefined, model: OrderTicket): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/OrderTicket/Update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/OrderTicket/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    query(filter: FilterContainer): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/OrderTicket/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IEmployeeClient {
    delete(id: number): Observable<FileResponse>;
    query(filter: FilterContainer): Observable<FileResponse>;
    create(model: Employee): Observable<FileResponse>;
    update(id: number | undefined, model: Employee): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeeClient implements IEmployeeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Employee/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    query(filter: FilterContainer): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Employee/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    create(model: Employee): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Employee/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number | undefined, model: Employee): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Employee/Update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICategoryClient {
    delete(id: number): Observable<FileResponse>;
    query(filter: FilterContainer): Observable<FileResponse>;
    create(model: TicketCategory): Observable<FileResponse>;
    update(id: number | undefined, model: TicketCategory): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoryClient implements ICategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Category/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    query(filter: FilterContainer): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Category/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processQuery(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    create(model: TicketCategory): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number | undefined, model: TicketCategory): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Category/Update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IDataTableClient {
    orders(request: DataTableRequest): Observable<FileResponse>;
    tickets(request: DataTableRequest): Observable<FileResponse>;
    employees(request: DataTableRequest): Observable<FileResponse>;
    categories(request: DataTableRequest): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class DataTableClient implements IDataTableClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    orders(request: DataTableRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DataTable/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrders(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processOrders(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    tickets(request: DataTableRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DataTable/Tickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTickets(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTickets(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    employees(request: DataTableRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DataTable/Employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployees(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployees(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    categories(request: DataTableRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DataTable/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICurrentUserClient {
    authenticationModel(): Observable<AuthenticationModel>;
}

@Injectable({
    providedIn: 'root'
})
export class CurrentUserClient implements ICurrentUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    authenticationModel(): Observable<AuthenticationModel> {
        let url_ = this.baseUrl + "/api/CurrentUser/AuthenticationModel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticationModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticationModel(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticationModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticationModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticationModel(response: HttpResponseBase): Observable<AuthenticationModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticationModel>(<any>null);
    }
}

export interface IDashboardClient {
    ordersByCategory(months: number | undefined, days: number | undefined): Observable<OrdersByCategoryQueryViewModel>;
    ordersRateOverTime(isMonths: boolean | undefined, count: number | undefined): Observable<OrdersRateOverTimeViewModel>;
    lowestSparesByStoreIds(storeIds: number[] | null | undefined): Observable<LowestSparesByStoreIdsQueryViewModel>;
    transactionsRateOverTime(storeIds: number[] | null | undefined, isMonths: boolean | undefined, count: number | undefined): Observable<TransactionsRateOverTimeViewModel>;
    orderSMSRateOverTime(isMonths: boolean | undefined, count: number | undefined): Observable<OrderSMSRateOverTimeViewModel>;
    availableSmsBalance(query: AvailableSmsBalanceQuery | null | undefined): Observable<AvailableSmsBalanceViewModel>;
    ticketsByEmployees(months: number | undefined, days: number | undefined): Observable<TicketsByEmployeesQueryViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class DashboardClient implements IDashboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    ordersByCategory(months: number | undefined, days: number | undefined): Observable<OrdersByCategoryQueryViewModel> {
        let url_ = this.baseUrl + "/api/Dashboard/OrdersByCategory?";
        if (months === null)
            throw new Error("The parameter 'months' cannot be null.");
        else if (months !== undefined)
            url_ += "Months=" + encodeURIComponent("" + months) + "&"; 
        if (days === null)
            throw new Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "Days=" + encodeURIComponent("" + days) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersByCategory(<any>response_);
                } catch (e) {
                    return <Observable<OrdersByCategoryQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrdersByCategoryQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processOrdersByCategory(response: HttpResponseBase): Observable<OrdersByCategoryQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrdersByCategoryQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrdersByCategoryQueryViewModel>(<any>null);
    }

    ordersRateOverTime(isMonths: boolean | undefined, count: number | undefined): Observable<OrdersRateOverTimeViewModel> {
        let url_ = this.baseUrl + "/api/Dashboard/OrdersRateOverTime?";
        if (isMonths === null)
            throw new Error("The parameter 'isMonths' cannot be null.");
        else if (isMonths !== undefined)
            url_ += "IsMonths=" + encodeURIComponent("" + isMonths) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersRateOverTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersRateOverTime(<any>response_);
                } catch (e) {
                    return <Observable<OrdersRateOverTimeViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrdersRateOverTimeViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processOrdersRateOverTime(response: HttpResponseBase): Observable<OrdersRateOverTimeViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrdersRateOverTimeViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrdersRateOverTimeViewModel>(<any>null);
    }

    lowestSparesByStoreIds(storeIds: number[] | null | undefined): Observable<LowestSparesByStoreIdsQueryViewModel> {
        let url_ = this.baseUrl + "/api/Dashboard/LowestSparesByStoreIdsQuery?";
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLowestSparesByStoreIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLowestSparesByStoreIds(<any>response_);
                } catch (e) {
                    return <Observable<LowestSparesByStoreIdsQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<LowestSparesByStoreIdsQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processLowestSparesByStoreIds(response: HttpResponseBase): Observable<LowestSparesByStoreIdsQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LowestSparesByStoreIdsQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LowestSparesByStoreIdsQueryViewModel>(<any>null);
    }

    transactionsRateOverTime(storeIds: number[] | null | undefined, isMonths: boolean | undefined, count: number | undefined): Observable<TransactionsRateOverTimeViewModel> {
        let url_ = this.baseUrl + "/api/Dashboard/TransactionsRateOverTime?";
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (isMonths === null)
            throw new Error("The parameter 'isMonths' cannot be null.");
        else if (isMonths !== undefined)
            url_ += "IsMonths=" + encodeURIComponent("" + isMonths) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransactionsRateOverTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransactionsRateOverTime(<any>response_);
                } catch (e) {
                    return <Observable<TransactionsRateOverTimeViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionsRateOverTimeViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processTransactionsRateOverTime(response: HttpResponseBase): Observable<TransactionsRateOverTimeViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionsRateOverTimeViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionsRateOverTimeViewModel>(<any>null);
    }

    orderSMSRateOverTime(isMonths: boolean | undefined, count: number | undefined): Observable<OrderSMSRateOverTimeViewModel> {
        let url_ = this.baseUrl + "/api/Dashboard/OrderSMSRateOverTime?";
        if (isMonths === null)
            throw new Error("The parameter 'isMonths' cannot be null.");
        else if (isMonths !== undefined)
            url_ += "IsMonths=" + encodeURIComponent("" + isMonths) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderSMSRateOverTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderSMSRateOverTime(<any>response_);
                } catch (e) {
                    return <Observable<OrderSMSRateOverTimeViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderSMSRateOverTimeViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processOrderSMSRateOverTime(response: HttpResponseBase): Observable<OrderSMSRateOverTimeViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderSMSRateOverTimeViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderSMSRateOverTimeViewModel>(<any>null);
    }

    availableSmsBalance(query: AvailableSmsBalanceQuery | null | undefined): Observable<AvailableSmsBalanceViewModel> {
        let url_ = this.baseUrl + "/api/Dashboard/AvailableSmsBalance?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableSmsBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableSmsBalance(<any>response_);
                } catch (e) {
                    return <Observable<AvailableSmsBalanceViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AvailableSmsBalanceViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processAvailableSmsBalance(response: HttpResponseBase): Observable<AvailableSmsBalanceViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvailableSmsBalanceViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AvailableSmsBalanceViewModel>(<any>null);
    }

    ticketsByEmployees(months: number | undefined, days: number | undefined): Observable<TicketsByEmployeesQueryViewModel> {
        let url_ = this.baseUrl + "/api/Dashboard/TicketsByEmployees?";
        if (months === null)
            throw new Error("The parameter 'months' cannot be null.");
        else if (months !== undefined)
            url_ += "Months=" + encodeURIComponent("" + months) + "&"; 
        if (days === null)
            throw new Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "Days=" + encodeURIComponent("" + days) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTicketsByEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTicketsByEmployees(<any>response_);
                } catch (e) {
                    return <Observable<TicketsByEmployeesQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketsByEmployeesQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processTicketsByEmployees(response: HttpResponseBase): Observable<TicketsByEmployeesQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketsByEmployeesQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketsByEmployeesQueryViewModel>(<any>null);
    }
}

export interface IEmployeesClient {
    search(sort: string | null | undefined, pageIndex: number | null | undefined, pageLength: number | null | undefined, filter: string | null | undefined): Observable<SearchEmployeesViewModel>;
    create(command: CreateEmployeeCommand): Observable<number>;
    update(id: number, command: UpdateEmployeeCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeesClient implements IEmployeesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(sort: string | null | undefined, pageIndex: number | null | undefined, pageLength: number | null | undefined, filter: string | null | undefined): Observable<SearchEmployeesViewModel> {
        let url_ = this.baseUrl + "/api/Employees/Search?";
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageLength !== undefined)
            url_ += "PageLength=" + encodeURIComponent("" + pageLength) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchEmployeesViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchEmployeesViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchEmployeesViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchEmployeesViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchEmployeesViewModel>(<any>null);
    }

    create(command: CreateEmployeeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateEmployeeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IFinancialTransactionsClient {
    search(query: SearchFinancialTransactionsQuery): Observable<SearchFinancialTransactionsQueryViewModel>;
    getById(id: number): Observable<SearchFinancialTransactionDto>;
    update(id: number, command: UpdateFinancialTransactionCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    statistics(query: FinancialTransactionsStatisticsQuery): Observable<FinancialTransactionsStatisticsQueryViewModel>;
    create(command: CreateFinancialTransactionCommand): Observable<number>;
    export(query: ExportFinancialTransactionQuery): Observable<ExportFinancialTransactionQueryViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class FinancialTransactionsClient implements IFinancialTransactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(query: SearchFinancialTransactionsQuery): Observable<SearchFinancialTransactionsQueryViewModel> {
        let url_ = this.baseUrl + "/api/FinancialTransactions/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchFinancialTransactionsQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchFinancialTransactionsQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchFinancialTransactionsQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchFinancialTransactionsQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchFinancialTransactionsQueryViewModel>(<any>null);
    }

    getById(id: number): Observable<SearchFinancialTransactionDto> {
        let url_ = this.baseUrl + "/api/FinancialTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SearchFinancialTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchFinancialTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SearchFinancialTransactionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchFinancialTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchFinancialTransactionDto>(<any>null);
    }

    update(id: number, command: UpdateFinancialTransactionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FinancialTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FinancialTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    statistics(query: FinancialTransactionsStatisticsQuery): Observable<FinancialTransactionsStatisticsQueryViewModel> {
        let url_ = this.baseUrl + "/api/FinancialTransactions/Statistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatistics(<any>response_);
                } catch (e) {
                    return <Observable<FinancialTransactionsStatisticsQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<FinancialTransactionsStatisticsQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processStatistics(response: HttpResponseBase): Observable<FinancialTransactionsStatisticsQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinancialTransactionsStatisticsQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FinancialTransactionsStatisticsQueryViewModel>(<any>null);
    }

    create(command: CreateFinancialTransactionCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/FinancialTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    export(query: ExportFinancialTransactionQuery): Observable<ExportFinancialTransactionQueryViewModel> {
        let url_ = this.baseUrl + "/api/FinancialTransactions/Export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExport(<any>response_);
                } catch (e) {
                    return <Observable<ExportFinancialTransactionQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExportFinancialTransactionQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processExport(response: HttpResponseBase): Observable<ExportFinancialTransactionQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFinancialTransactionQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExportFinancialTransactionQueryViewModel>(<any>null);
    }
}

export interface IInventoriesClient {
    search(query: SearchInventoriesQuery): Observable<SearchInventoriesQueryViewModel>;
    create(command: CreateInventoryCommand): Observable<number>;
    update(id: number, command: UpdateInventoryCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class InventoriesClient implements IInventoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(query: SearchInventoriesQuery): Observable<SearchInventoriesQueryViewModel> {
        let url_ = this.baseUrl + "/api/Inventories/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchInventoriesQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchInventoriesQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchInventoriesQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchInventoriesQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchInventoriesQueryViewModel>(<any>null);
    }

    create(command: CreateInventoryCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Inventories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateInventoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Inventories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Inventories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IInventoryTransactionsClient {
    search(query: SearchITransactionsQuery): Observable<SearchITransactionsQueryViewModel>;
    create(command: CreateInventoryTransactionCommand): Observable<number>;
    update(id: number, command: UpdateInventoryTransactionCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class InventoryTransactionsClient implements IInventoryTransactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(query: SearchITransactionsQuery): Observable<SearchITransactionsQueryViewModel> {
        let url_ = this.baseUrl + "/api/InventoryTransactions/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchITransactionsQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchITransactionsQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchITransactionsQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchITransactionsQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchITransactionsQueryViewModel>(<any>null);
    }

    create(command: CreateInventoryTransactionCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/InventoryTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateInventoryTransactionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/InventoryTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/InventoryTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IOrderSMSMessagesClient {
    search(query: SearchOrderSMSMessagesQuery): Observable<SearchOrderSMSMessagesQueryViewModel>;
    addOrders(command: AddOrdersForSMSMessageCommand): Observable<FileResponse>;
    update(id: number, command: UpdateOrderPhonesCommand): Observable<FileResponse>;
    delete(ids: number[]): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrderSMSMessagesClient implements IOrderSMSMessagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(query: SearchOrderSMSMessagesQuery): Observable<SearchOrderSMSMessagesQueryViewModel> {
        let url_ = this.baseUrl + "/api/OrderSMSMessages/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchOrderSMSMessagesQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchOrderSMSMessagesQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchOrderSMSMessagesQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchOrderSMSMessagesQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchOrderSMSMessagesQueryViewModel>(<any>null);
    }

    addOrders(command: AddOrdersForSMSMessageCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/OrderSMSMessages/AddOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrders(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrders(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateOrderPhonesCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/OrderSMSMessages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(ids: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/OrderSMSMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ISMSMessagesClient {
    search(query: SearchSMSMessagesQuery): Observable<SearchSMSMessagesViewModel>;
    getById(id: number): Observable<SMSMessageDto>;
    update(id: number, command: UpdateSMSMessageCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    send(command: SendSMSMessageCommand): Observable<SearchOrderSMSMessageDto>;
    create(command: CreateSMSMessageCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class SMSMessagesClient implements ISMSMessagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(query: SearchSMSMessagesQuery): Observable<SearchSMSMessagesViewModel> {
        let url_ = this.baseUrl + "/api/SMSMessages/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchSMSMessagesViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchSMSMessagesViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchSMSMessagesViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchSMSMessagesViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchSMSMessagesViewModel>(<any>null);
    }

    getById(id: number): Observable<SMSMessageDto> {
        let url_ = this.baseUrl + "/api/SMSMessages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SMSMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SMSMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SMSMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SMSMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SMSMessageDto>(<any>null);
    }

    update(id: number, command: UpdateSMSMessageCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SMSMessages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SMSMessages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    send(command: SendSMSMessageCommand): Observable<SearchOrderSMSMessageDto> {
        let url_ = this.baseUrl + "/api/SMSMessages/Send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(<any>response_);
                } catch (e) {
                    return <Observable<SearchOrderSMSMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchOrderSMSMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<SearchOrderSMSMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchOrderSMSMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchOrderSMSMessageDto>(<any>null);
    }

    create(command: CreateSMSMessageCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/SMSMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export interface ISparePartsClient {
    search(query: SearchSparePartsQuery): Observable<SearchSparePartsViewModel>;
    getById(id: number): Observable<SparePartDto>;
    update(id: number, command: UpdateSparePartCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    create(command: CreateSparePartCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class SparePartsClient implements ISparePartsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(query: SearchSparePartsQuery): Observable<SearchSparePartsViewModel> {
        let url_ = this.baseUrl + "/api/SpareParts/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchSparePartsViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchSparePartsViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchSparePartsViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchSparePartsViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchSparePartsViewModel>(<any>null);
    }

    getById(id: number): Observable<SparePartDto> {
        let url_ = this.baseUrl + "/api/SpareParts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SparePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SparePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SparePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SparePartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SparePartDto>(<any>null);
    }

    update(id: number, command: UpdateSparePartCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SpareParts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SpareParts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    create(command: CreateSparePartCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/SpareParts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export interface IStoresClient {
    search(query: SearchStoresQuery): Observable<SearchStoresQueryViewModel>;
    getById(id: number): Observable<SearchStoreDto>;
    update(id: number, command: UpdateStoreCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    create(command: CreateStoreCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class StoresClient implements IStoresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(query: SearchStoresQuery): Observable<SearchStoresQueryViewModel> {
        let url_ = this.baseUrl + "/api/Stores/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchStoresQueryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchStoresQueryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchStoresQueryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchStoresQueryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchStoresQueryViewModel>(<any>null);
    }

    getById(id: number): Observable<SearchStoreDto> {
        let url_ = this.baseUrl + "/api/Stores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SearchStoreDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchStoreDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SearchStoreDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchStoreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchStoreDto>(<any>null);
    }

    update(id: number, command: UpdateStoreCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Stores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Stores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    create(command: CreateStoreCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export interface ITodoItemsClient {
    create(command: CreateTodoItemCommand): Observable<number>;
    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITodoListsClient {
    get(): Observable<TodosVm>;
    create(command: CreateTodoListCommand): Observable<number>;
    get2(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TodosVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodosVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodosVm>(<any>null);
    }

    create(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IValueGroupsClient {
    getTransactionTypes(): Observable<ValueGroupDto[]>;
    getReferenceTypes(): Observable<ValueGroupDto[]>;
    getFinancialTransactionTypes(): Observable<ValueGroupDto[]>;
    getById(id: number): Observable<ValueGroupDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ValueGroupsClient implements IValueGroupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getTransactionTypes(): Observable<ValueGroupDto[]> {
        let url_ = this.baseUrl + "/api/ValueGroups/GetTransactionTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypes(<any>response_);
                } catch (e) {
                    return <Observable<ValueGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionTypes(response: HttpResponseBase): Observable<ValueGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValueGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueGroupDto[]>(<any>null);
    }

    getReferenceTypes(): Observable<ValueGroupDto[]> {
        let url_ = this.baseUrl + "/api/ValueGroups/GetReferenceTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypes(<any>response_);
                } catch (e) {
                    return <Observable<ValueGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypes(response: HttpResponseBase): Observable<ValueGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValueGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueGroupDto[]>(<any>null);
    }

    getFinancialTransactionTypes(): Observable<ValueGroupDto[]> {
        let url_ = this.baseUrl + "/api/ValueGroups/GetFinancialTransactionTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialTransactionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialTransactionTypes(<any>response_);
                } catch (e) {
                    return <Observable<ValueGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFinancialTransactionTypes(response: HttpResponseBase): Observable<ValueGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValueGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueGroupDto[]>(<any>null);
    }

    getById(id: number): Observable<ValueGroupDto> {
        let url_ = this.baseUrl + "/api/ValueGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ValueGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ValueGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueGroupDto>(<any>null);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class CreateOrderViewModel implements ICreateOrderViewModel {
    oid?: number | undefined;
    address?: string | undefined;
    customer?: string | undefined;
    complaint?: string | undefined;
    dateAssigned?: Date | undefined;
    model?: string | undefined;
    street?: string | undefined;
    orderid?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    product?: string | undefined;
    region?: string | undefined;
    activeTicket?: number | undefined;
    workOrderId?: string | undefined;
    sapNumber?: number | undefined;
    caseNumber?: string | undefined;

    constructor(data?: ICreateOrderViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"];
            this.address = _data["address"];
            this.customer = _data["customer"];
            this.complaint = _data["complaint"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.model = _data["model"];
            this.street = _data["street"];
            this.orderid = _data["orderid"];
            this.primaryPhone = _data["primaryPhone"];
            this.secondaryPhone = _data["secondaryPhone"];
            this.product = _data["product"];
            this.region = _data["region"];
            this.activeTicket = _data["activeTicket"];
            this.workOrderId = _data["workOrderId"];
            this.sapNumber = _data["sapNumber"];
            this.caseNumber = _data["caseNumber"];
        }
    }

    static fromJS(data: any): CreateOrderViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid;
        data["address"] = this.address;
        data["customer"] = this.customer;
        data["complaint"] = this.complaint;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["model"] = this.model;
        data["street"] = this.street;
        data["orderid"] = this.orderid;
        data["primaryPhone"] = this.primaryPhone;
        data["secondaryPhone"] = this.secondaryPhone;
        data["product"] = this.product;
        data["region"] = this.region;
        data["activeTicket"] = this.activeTicket;
        data["workOrderId"] = this.workOrderId;
        data["sapNumber"] = this.sapNumber;
        data["caseNumber"] = this.caseNumber;
        return data; 
    }
}

export interface ICreateOrderViewModel {
    oid?: number | undefined;
    address?: string | undefined;
    customer?: string | undefined;
    complaint?: string | undefined;
    dateAssigned?: Date | undefined;
    model?: string | undefined;
    street?: string | undefined;
    orderid?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    product?: string | undefined;
    region?: string | undefined;
    activeTicket?: number | undefined;
    workOrderId?: string | undefined;
    sapNumber?: number | undefined;
    caseNumber?: string | undefined;
}

export class PatchOrderEdit implements IPatchOrderEdit {
    orders?: number[] | undefined;
    tickets?: number[] | undefined;
    orderFields?: string[] | undefined;
    ticketFields?: string[] | undefined;
    templateOrder?: Order | undefined;
    templateTicket?: OrderTicket | undefined;

    constructor(data?: IPatchOrderEdit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(item);
            }
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(item);
            }
            if (Array.isArray(_data["orderFields"])) {
                this.orderFields = [] as any;
                for (let item of _data["orderFields"])
                    this.orderFields!.push(item);
            }
            if (Array.isArray(_data["ticketFields"])) {
                this.ticketFields = [] as any;
                for (let item of _data["ticketFields"])
                    this.ticketFields!.push(item);
            }
            this.templateOrder = _data["templateOrder"] ? Order.fromJS(_data["templateOrder"]) : <any>undefined;
            this.templateTicket = _data["templateTicket"] ? OrderTicket.fromJS(_data["templateTicket"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PatchOrderEdit {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOrderEdit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item);
        }
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item);
        }
        if (Array.isArray(this.orderFields)) {
            data["orderFields"] = [];
            for (let item of this.orderFields)
                data["orderFields"].push(item);
        }
        if (Array.isArray(this.ticketFields)) {
            data["ticketFields"] = [];
            for (let item of this.ticketFields)
                data["ticketFields"].push(item);
        }
        data["templateOrder"] = this.templateOrder ? this.templateOrder.toJSON() : <any>undefined;
        data["templateTicket"] = this.templateTicket ? this.templateTicket.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPatchOrderEdit {
    orders?: number[] | undefined;
    tickets?: number[] | undefined;
    orderFields?: string[] | undefined;
    ticketFields?: string[] | undefined;
    templateOrder?: Order | undefined;
    templateTicket?: OrderTicket | undefined;
}

export class Order implements IOrder {
    oid?: number;
    orderid?: string | undefined;
    customer?: string | undefined;
    region?: string | undefined;
    city?: string | undefined;
    town?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    product?: string | undefined;
    model?: string | undefined;
    complaint?: string | undefined;
    dateAssigned?: Date | undefined;
    interfaceStatus?: number | undefined;
    dateLastDelayed?: Date | undefined;
    reasonLastDelayed?: string | undefined;
    isSynchronized?: boolean | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    reportsOverview?: string | undefined;
    isArchived?: boolean | undefined;
    isArgent?: boolean | undefined;
    activeTicket?: number | undefined;
    overviewNotes?: string | undefined;
    tag?: string | undefined;
    priority?: number | undefined;
    siteIndex?: number | undefined;
    rowBytesCount?: number | undefined;
    workOrderId?: string | undefined;
    caseNumber?: string | undefined;
    sapnumber?: number | undefined;
    activeTicketNavigation?: OrderTicket | undefined;
    orderTicket?: OrderTicket[] | undefined;
    orderSMSMessages?: OrderSMSMessage[] | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"];
            this.orderid = _data["orderid"];
            this.customer = _data["customer"];
            this.region = _data["region"];
            this.city = _data["city"];
            this.town = _data["town"];
            this.street = _data["street"];
            this.address = _data["address"];
            this.primaryPhone = _data["primaryPhone"];
            this.secondaryPhone = _data["secondaryPhone"];
            this.product = _data["product"];
            this.model = _data["model"];
            this.complaint = _data["complaint"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.interfaceStatus = _data["interfaceStatus"];
            this.dateLastDelayed = _data["dateLastDelayed"] ? new Date(_data["dateLastDelayed"].toString()) : <any>undefined;
            this.reasonLastDelayed = _data["reasonLastDelayed"];
            this.isSynchronized = _data["isSynchronized"];
            this.optimisticLockField = _data["optimisticLockField"];
            this.gcrecord = _data["gcrecord"];
            this.reportsOverview = _data["reportsOverview"];
            this.isArchived = _data["isArchived"];
            this.isArgent = _data["isArgent"];
            this.activeTicket = _data["activeTicket"];
            this.overviewNotes = _data["overviewNotes"];
            this.tag = _data["tag"];
            this.priority = _data["priority"];
            this.siteIndex = _data["siteIndex"];
            this.rowBytesCount = _data["rowBytesCount"];
            this.workOrderId = _data["workOrderId"];
            this.caseNumber = _data["caseNumber"];
            this.sapnumber = _data["sapnumber"];
            this.activeTicketNavigation = _data["activeTicketNavigation"] ? OrderTicket.fromJS(_data["activeTicketNavigation"]) : <any>undefined;
            if (Array.isArray(_data["orderTicket"])) {
                this.orderTicket = [] as any;
                for (let item of _data["orderTicket"])
                    this.orderTicket!.push(OrderTicket.fromJS(item));
            }
            if (Array.isArray(_data["orderSMSMessages"])) {
                this.orderSMSMessages = [] as any;
                for (let item of _data["orderSMSMessages"])
                    this.orderSMSMessages!.push(OrderSMSMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid;
        data["orderid"] = this.orderid;
        data["customer"] = this.customer;
        data["region"] = this.region;
        data["city"] = this.city;
        data["town"] = this.town;
        data["street"] = this.street;
        data["address"] = this.address;
        data["primaryPhone"] = this.primaryPhone;
        data["secondaryPhone"] = this.secondaryPhone;
        data["product"] = this.product;
        data["model"] = this.model;
        data["complaint"] = this.complaint;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["interfaceStatus"] = this.interfaceStatus;
        data["dateLastDelayed"] = this.dateLastDelayed ? this.dateLastDelayed.toISOString() : <any>undefined;
        data["reasonLastDelayed"] = this.reasonLastDelayed;
        data["isSynchronized"] = this.isSynchronized;
        data["optimisticLockField"] = this.optimisticLockField;
        data["gcrecord"] = this.gcrecord;
        data["reportsOverview"] = this.reportsOverview;
        data["isArchived"] = this.isArchived;
        data["isArgent"] = this.isArgent;
        data["activeTicket"] = this.activeTicket;
        data["overviewNotes"] = this.overviewNotes;
        data["tag"] = this.tag;
        data["priority"] = this.priority;
        data["siteIndex"] = this.siteIndex;
        data["rowBytesCount"] = this.rowBytesCount;
        data["workOrderId"] = this.workOrderId;
        data["caseNumber"] = this.caseNumber;
        data["sapnumber"] = this.sapnumber;
        data["activeTicketNavigation"] = this.activeTicketNavigation ? this.activeTicketNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.orderTicket)) {
            data["orderTicket"] = [];
            for (let item of this.orderTicket)
                data["orderTicket"].push(item.toJSON());
        }
        if (Array.isArray(this.orderSMSMessages)) {
            data["orderSMSMessages"] = [];
            for (let item of this.orderSMSMessages)
                data["orderSMSMessages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrder {
    oid?: number;
    orderid?: string | undefined;
    customer?: string | undefined;
    region?: string | undefined;
    city?: string | undefined;
    town?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    product?: string | undefined;
    model?: string | undefined;
    complaint?: string | undefined;
    dateAssigned?: Date | undefined;
    interfaceStatus?: number | undefined;
    dateLastDelayed?: Date | undefined;
    reasonLastDelayed?: string | undefined;
    isSynchronized?: boolean | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    reportsOverview?: string | undefined;
    isArchived?: boolean | undefined;
    isArgent?: boolean | undefined;
    activeTicket?: number | undefined;
    overviewNotes?: string | undefined;
    tag?: string | undefined;
    priority?: number | undefined;
    siteIndex?: number | undefined;
    rowBytesCount?: number | undefined;
    workOrderId?: string | undefined;
    caseNumber?: string | undefined;
    sapnumber?: number | undefined;
    activeTicketNavigation?: OrderTicket | undefined;
    orderTicket?: OrderTicket[] | undefined;
    orderSMSMessages?: OrderSMSMessage[] | undefined;
}

export class OrderTicket implements IOrderTicket {
    oid?: number;
    userName?: string | undefined;
    date?: Date | undefined;
    report?: string | undefined;
    order?: number | undefined;
    employee?: number | undefined;
    category?: number | undefined;
    isActive?: boolean | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    causeUnCompletion?: boolean | undefined;
    notable?: boolean | undefined;
    includeInOrderNotes?: boolean | undefined;
    categoryNavigation?: TicketCategory | undefined;
    employeeNavigation?: Employee | undefined;
    order1?: Order | undefined;
    orderNavigation?: Order[] | undefined;

    constructor(data?: IOrderTicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"];
            this.userName = _data["userName"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.report = _data["report"];
            this.order = _data["order"];
            this.employee = _data["employee"];
            this.category = _data["category"];
            this.isActive = _data["isActive"];
            this.optimisticLockField = _data["optimisticLockField"];
            this.gcrecord = _data["gcrecord"];
            this.causeUnCompletion = _data["causeUnCompletion"];
            this.notable = _data["notable"];
            this.includeInOrderNotes = _data["includeInOrderNotes"];
            this.categoryNavigation = _data["categoryNavigation"] ? TicketCategory.fromJS(_data["categoryNavigation"]) : <any>undefined;
            this.employeeNavigation = _data["employeeNavigation"] ? Employee.fromJS(_data["employeeNavigation"]) : <any>undefined;
            this.order1 = _data["order1"] ? Order.fromJS(_data["order1"]) : <any>undefined;
            if (Array.isArray(_data["orderNavigation"])) {
                this.orderNavigation = [] as any;
                for (let item of _data["orderNavigation"])
                    this.orderNavigation!.push(Order.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderTicket {
        data = typeof data === 'object' ? data : {};
        let result = new OrderTicket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid;
        data["userName"] = this.userName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["report"] = this.report;
        data["order"] = this.order;
        data["employee"] = this.employee;
        data["category"] = this.category;
        data["isActive"] = this.isActive;
        data["optimisticLockField"] = this.optimisticLockField;
        data["gcrecord"] = this.gcrecord;
        data["causeUnCompletion"] = this.causeUnCompletion;
        data["notable"] = this.notable;
        data["includeInOrderNotes"] = this.includeInOrderNotes;
        data["categoryNavigation"] = this.categoryNavigation ? this.categoryNavigation.toJSON() : <any>undefined;
        data["employeeNavigation"] = this.employeeNavigation ? this.employeeNavigation.toJSON() : <any>undefined;
        data["order1"] = this.order1 ? this.order1.toJSON() : <any>undefined;
        if (Array.isArray(this.orderNavigation)) {
            data["orderNavigation"] = [];
            for (let item of this.orderNavigation)
                data["orderNavigation"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderTicket {
    oid?: number;
    userName?: string | undefined;
    date?: Date | undefined;
    report?: string | undefined;
    order?: number | undefined;
    employee?: number | undefined;
    category?: number | undefined;
    isActive?: boolean | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    causeUnCompletion?: boolean | undefined;
    notable?: boolean | undefined;
    includeInOrderNotes?: boolean | undefined;
    categoryNavigation?: TicketCategory | undefined;
    employeeNavigation?: Employee | undefined;
    order1?: Order | undefined;
    orderNavigation?: Order[] | undefined;
}

export class TicketCategory implements ITicketCategory {
    oid?: number;
    title?: string | undefined;
    description?: string | undefined;
    backColor?: number | undefined;
    fontColor?: number | undefined;
    fontStyle?: number | undefined;
    supportApplyInBatches?: boolean | undefined;
    allowDuplicates?: boolean | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    reportable?: boolean | undefined;
    priority?: number | undefined;
    activatable?: boolean | undefined;
    includeInOrderNotes?: boolean | undefined;
    orderTicket?: OrderTicket[] | undefined;

    constructor(data?: ITicketCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.backColor = _data["backColor"];
            this.fontColor = _data["fontColor"];
            this.fontStyle = _data["fontStyle"];
            this.supportApplyInBatches = _data["supportApplyInBatches"];
            this.allowDuplicates = _data["allowDuplicates"];
            this.optimisticLockField = _data["optimisticLockField"];
            this.gcrecord = _data["gcrecord"];
            this.reportable = _data["reportable"];
            this.priority = _data["priority"];
            this.activatable = _data["activatable"];
            this.includeInOrderNotes = _data["includeInOrderNotes"];
            if (Array.isArray(_data["orderTicket"])) {
                this.orderTicket = [] as any;
                for (let item of _data["orderTicket"])
                    this.orderTicket!.push(OrderTicket.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketCategory {
        data = typeof data === 'object' ? data : {};
        let result = new TicketCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid;
        data["title"] = this.title;
        data["description"] = this.description;
        data["backColor"] = this.backColor;
        data["fontColor"] = this.fontColor;
        data["fontStyle"] = this.fontStyle;
        data["supportApplyInBatches"] = this.supportApplyInBatches;
        data["allowDuplicates"] = this.allowDuplicates;
        data["optimisticLockField"] = this.optimisticLockField;
        data["gcrecord"] = this.gcrecord;
        data["reportable"] = this.reportable;
        data["priority"] = this.priority;
        data["activatable"] = this.activatable;
        data["includeInOrderNotes"] = this.includeInOrderNotes;
        if (Array.isArray(this.orderTicket)) {
            data["orderTicket"] = [];
            for (let item of this.orderTicket)
                data["orderTicket"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITicketCategory {
    oid?: number;
    title?: string | undefined;
    description?: string | undefined;
    backColor?: number | undefined;
    fontColor?: number | undefined;
    fontStyle?: number | undefined;
    supportApplyInBatches?: boolean | undefined;
    allowDuplicates?: boolean | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    reportable?: boolean | undefined;
    priority?: number | undefined;
    activatable?: boolean | undefined;
    includeInOrderNotes?: boolean | undefined;
    orderTicket?: OrderTicket[] | undefined;
}

export class Employee implements IEmployee {
    oid?: number;
    fullName?: string | undefined;
    displayName?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    province?: string | undefined;
    city?: string | undefined;
    town?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    birthdate?: Date | undefined;
    identityNumber?: string | undefined;
    dateEnrolled?: Date | undefined;
    isActive?: boolean | undefined;
    userName?: string | undefined;
    changePasswordOnFirstLogon?: boolean | undefined;
    storedPassword?: string | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    objectType?: number | undefined;
    isTechnician?: boolean | undefined;
    stores?: Store[] | undefined;
    financialTransactions?: FinancialTransaction[] | undefined;
    orderTicket?: OrderTicket[] | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"];
            this.fullName = _data["fullName"];
            this.displayName = _data["displayName"];
            this.primaryPhone = _data["primaryPhone"];
            this.secondaryPhone = _data["secondaryPhone"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.town = _data["town"];
            this.street = _data["street"];
            this.address = _data["address"];
            this.birthdate = _data["birthdate"] ? new Date(_data["birthdate"].toString()) : <any>undefined;
            this.identityNumber = _data["identityNumber"];
            this.dateEnrolled = _data["dateEnrolled"] ? new Date(_data["dateEnrolled"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.userName = _data["userName"];
            this.changePasswordOnFirstLogon = _data["changePasswordOnFirstLogon"];
            this.storedPassword = _data["storedPassword"];
            this.optimisticLockField = _data["optimisticLockField"];
            this.gcrecord = _data["gcrecord"];
            this.objectType = _data["objectType"];
            this.isTechnician = _data["isTechnician"];
            if (Array.isArray(_data["stores"])) {
                this.stores = [] as any;
                for (let item of _data["stores"])
                    this.stores!.push(Store.fromJS(item));
            }
            if (Array.isArray(_data["financialTransactions"])) {
                this.financialTransactions = [] as any;
                for (let item of _data["financialTransactions"])
                    this.financialTransactions!.push(FinancialTransaction.fromJS(item));
            }
            if (Array.isArray(_data["orderTicket"])) {
                this.orderTicket = [] as any;
                for (let item of _data["orderTicket"])
                    this.orderTicket!.push(OrderTicket.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid;
        data["fullName"] = this.fullName;
        data["displayName"] = this.displayName;
        data["primaryPhone"] = this.primaryPhone;
        data["secondaryPhone"] = this.secondaryPhone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["town"] = this.town;
        data["street"] = this.street;
        data["address"] = this.address;
        data["birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["identityNumber"] = this.identityNumber;
        data["dateEnrolled"] = this.dateEnrolled ? this.dateEnrolled.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["userName"] = this.userName;
        data["changePasswordOnFirstLogon"] = this.changePasswordOnFirstLogon;
        data["storedPassword"] = this.storedPassword;
        data["optimisticLockField"] = this.optimisticLockField;
        data["gcrecord"] = this.gcrecord;
        data["objectType"] = this.objectType;
        data["isTechnician"] = this.isTechnician;
        if (Array.isArray(this.stores)) {
            data["stores"] = [];
            for (let item of this.stores)
                data["stores"].push(item.toJSON());
        }
        if (Array.isArray(this.financialTransactions)) {
            data["financialTransactions"] = [];
            for (let item of this.financialTransactions)
                data["financialTransactions"].push(item.toJSON());
        }
        if (Array.isArray(this.orderTicket)) {
            data["orderTicket"] = [];
            for (let item of this.orderTicket)
                data["orderTicket"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmployee {
    oid?: number;
    fullName?: string | undefined;
    displayName?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    province?: string | undefined;
    city?: string | undefined;
    town?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    birthdate?: Date | undefined;
    identityNumber?: string | undefined;
    dateEnrolled?: Date | undefined;
    isActive?: boolean | undefined;
    userName?: string | undefined;
    changePasswordOnFirstLogon?: boolean | undefined;
    storedPassword?: string | undefined;
    optimisticLockField?: number | undefined;
    gcrecord?: number | undefined;
    objectType?: number | undefined;
    isTechnician?: boolean | undefined;
    stores?: Store[] | undefined;
    financialTransactions?: FinancialTransaction[] | undefined;
    orderTicket?: OrderTicket[] | undefined;
}

export abstract class AuditableEntity implements IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date | undefined;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date | undefined;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
}

export class Store extends AuditableEntity implements IStore {
    storeId?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
    isDeleted?: boolean | undefined;
    administratorNavigation?: Employee | undefined;
    inventories?: Inventory[] | undefined;

    constructor(data?: IStore) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.storeId = _data["storeId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.administrator = _data["administrator"];
            this.isDeleted = _data["isDeleted"];
            this.administratorNavigation = _data["administratorNavigation"] ? Employee.fromJS(_data["administratorNavigation"]) : <any>undefined;
            if (Array.isArray(_data["inventories"])) {
                this.inventories = [] as any;
                for (let item of _data["inventories"])
                    this.inventories!.push(Inventory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["administrator"] = this.administrator;
        data["isDeleted"] = this.isDeleted;
        data["administratorNavigation"] = this.administratorNavigation ? this.administratorNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.inventories)) {
            data["inventories"] = [];
            for (let item of this.inventories)
                data["inventories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IStore extends IAuditableEntity {
    storeId?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
    isDeleted?: boolean | undefined;
    administratorNavigation?: Employee | undefined;
    inventories?: Inventory[] | undefined;
}

export class Inventory extends AuditableEntity implements IInventory {
    inventoryId?: number;
    storeId?: number;
    sparePartId?: number;
    openingBalance?: number;
    currentBalance?: number;
    isDeleted?: boolean | undefined;
    sparePart?: SparePart | undefined;
    store?: Store | undefined;
    inventoryTransactions?: InventoryTransaction[] | undefined;

    constructor(data?: IInventory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.inventoryId = _data["inventoryId"];
            this.storeId = _data["storeId"];
            this.sparePartId = _data["sparePartId"];
            this.openingBalance = _data["openingBalance"];
            this.currentBalance = _data["currentBalance"];
            this.isDeleted = _data["isDeleted"];
            this.sparePart = _data["sparePart"] ? SparePart.fromJS(_data["sparePart"]) : <any>undefined;
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
            if (Array.isArray(_data["inventoryTransactions"])) {
                this.inventoryTransactions = [] as any;
                for (let item of _data["inventoryTransactions"])
                    this.inventoryTransactions!.push(InventoryTransaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Inventory {
        data = typeof data === 'object' ? data : {};
        let result = new Inventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryId"] = this.inventoryId;
        data["storeId"] = this.storeId;
        data["sparePartId"] = this.sparePartId;
        data["openingBalance"] = this.openingBalance;
        data["currentBalance"] = this.currentBalance;
        data["isDeleted"] = this.isDeleted;
        data["sparePart"] = this.sparePart ? this.sparePart.toJSON() : <any>undefined;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        if (Array.isArray(this.inventoryTransactions)) {
            data["inventoryTransactions"] = [];
            for (let item of this.inventoryTransactions)
                data["inventoryTransactions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IInventory extends IAuditableEntity {
    inventoryId?: number;
    storeId?: number;
    sparePartId?: number;
    openingBalance?: number;
    currentBalance?: number;
    isDeleted?: boolean | undefined;
    sparePart?: SparePart | undefined;
    store?: Store | undefined;
    inventoryTransactions?: InventoryTransaction[] | undefined;
}

export class SparePart extends AuditableEntity implements ISparePart {
    sparePartId?: number;
    barcode?: string | undefined;
    title?: string | undefined;
    category?: number | undefined;
    description?: string | undefined;
    isDeleted?: boolean | undefined;
    categoryNavigation?: ValueGroup | undefined;
    inventories?: Inventory[] | undefined;

    constructor(data?: ISparePart) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sparePartId = _data["sparePartId"];
            this.barcode = _data["barcode"];
            this.title = _data["title"];
            this.category = _data["category"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.categoryNavigation = _data["categoryNavigation"] ? ValueGroup.fromJS(_data["categoryNavigation"]) : <any>undefined;
            if (Array.isArray(_data["inventories"])) {
                this.inventories = [] as any;
                for (let item of _data["inventories"])
                    this.inventories!.push(Inventory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SparePart {
        data = typeof data === 'object' ? data : {};
        let result = new SparePart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sparePartId"] = this.sparePartId;
        data["barcode"] = this.barcode;
        data["title"] = this.title;
        data["category"] = this.category;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["categoryNavigation"] = this.categoryNavigation ? this.categoryNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.inventories)) {
            data["inventories"] = [];
            for (let item of this.inventories)
                data["inventories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISparePart extends IAuditableEntity {
    sparePartId?: number;
    barcode?: string | undefined;
    title?: string | undefined;
    category?: number | undefined;
    description?: string | undefined;
    isDeleted?: boolean | undefined;
    categoryNavigation?: ValueGroup | undefined;
    inventories?: Inventory[] | undefined;
}

export class ValueGroup extends AuditableEntity implements IValueGroup {
    valueGroupId?: number;
    value?: string | undefined;
    group?: string | undefined;
    isDeleted?: boolean | undefined;
    inventoryTransactionTypes?: InventoryTransaction[] | undefined;
    financialTransactionTypes?: FinancialTransaction[] | undefined;
    sparePartCategories?: SparePart[] | undefined;

    constructor(data?: IValueGroup) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.valueGroupId = _data["valueGroupId"];
            this.value = _data["value"];
            this.group = _data["group"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["inventoryTransactionTypes"])) {
                this.inventoryTransactionTypes = [] as any;
                for (let item of _data["inventoryTransactionTypes"])
                    this.inventoryTransactionTypes!.push(InventoryTransaction.fromJS(item));
            }
            if (Array.isArray(_data["financialTransactionTypes"])) {
                this.financialTransactionTypes = [] as any;
                for (let item of _data["financialTransactionTypes"])
                    this.financialTransactionTypes!.push(FinancialTransaction.fromJS(item));
            }
            if (Array.isArray(_data["sparePartCategories"])) {
                this.sparePartCategories = [] as any;
                for (let item of _data["sparePartCategories"])
                    this.sparePartCategories!.push(SparePart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValueGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ValueGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueGroupId"] = this.valueGroupId;
        data["value"] = this.value;
        data["group"] = this.group;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.inventoryTransactionTypes)) {
            data["inventoryTransactionTypes"] = [];
            for (let item of this.inventoryTransactionTypes)
                data["inventoryTransactionTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.financialTransactionTypes)) {
            data["financialTransactionTypes"] = [];
            for (let item of this.financialTransactionTypes)
                data["financialTransactionTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.sparePartCategories)) {
            data["sparePartCategories"] = [];
            for (let item of this.sparePartCategories)
                data["sparePartCategories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IValueGroup extends IAuditableEntity {
    valueGroupId?: number;
    value?: string | undefined;
    group?: string | undefined;
    isDeleted?: boolean | undefined;
    inventoryTransactionTypes?: InventoryTransaction[] | undefined;
    financialTransactionTypes?: FinancialTransaction[] | undefined;
    sparePartCategories?: SparePart[] | undefined;
}

export class InventoryTransaction extends AuditableEntity implements IInventoryTransaction {
    transactionId?: number;
    inventoryId?: number;
    type?: number | undefined;
    amount?: number | undefined;
    description?: string | undefined;
    referenceType?: number | undefined;
    referenceId?: string | undefined;
    isDeleted?: boolean | undefined;
    inventory?: Inventory | undefined;
    typeNavigation?: ValueGroup | undefined;

    constructor(data?: IInventoryTransaction) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.inventoryId = _data["inventoryId"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.referenceType = _data["referenceType"];
            this.referenceId = _data["referenceId"];
            this.isDeleted = _data["isDeleted"];
            this.inventory = _data["inventory"] ? Inventory.fromJS(_data["inventory"]) : <any>undefined;
            this.typeNavigation = _data["typeNavigation"] ? ValueGroup.fromJS(_data["typeNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InventoryTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["inventoryId"] = this.inventoryId;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["referenceType"] = this.referenceType;
        data["referenceId"] = this.referenceId;
        data["isDeleted"] = this.isDeleted;
        data["inventory"] = this.inventory ? this.inventory.toJSON() : <any>undefined;
        data["typeNavigation"] = this.typeNavigation ? this.typeNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IInventoryTransaction extends IAuditableEntity {
    transactionId?: number;
    inventoryId?: number;
    type?: number | undefined;
    amount?: number | undefined;
    description?: string | undefined;
    referenceType?: number | undefined;
    referenceId?: string | undefined;
    isDeleted?: boolean | undefined;
    inventory?: Inventory | undefined;
    typeNavigation?: ValueGroup | undefined;
}

export class FinancialTransaction extends AuditableEntity implements IFinancialTransaction {
    transactionId?: number;
    date?: Date;
    type?: number | undefined;
    amount?: number | undefined;
    title?: string | undefined;
    typeNavigation?: ValueGroup | undefined;
    remarks?: string | undefined;
    isDeleted?: boolean | undefined;
    employeeId?: number | undefined;
    employeeNavigation?: Employee | undefined;

    constructor(data?: IFinancialTransaction) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.title = _data["title"];
            this.typeNavigation = _data["typeNavigation"] ? ValueGroup.fromJS(_data["typeNavigation"]) : <any>undefined;
            this.remarks = _data["remarks"];
            this.isDeleted = _data["isDeleted"];
            this.employeeId = _data["employeeId"];
            this.employeeNavigation = _data["employeeNavigation"] ? Employee.fromJS(_data["employeeNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FinancialTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["title"] = this.title;
        data["typeNavigation"] = this.typeNavigation ? this.typeNavigation.toJSON() : <any>undefined;
        data["remarks"] = this.remarks;
        data["isDeleted"] = this.isDeleted;
        data["employeeId"] = this.employeeId;
        data["employeeNavigation"] = this.employeeNavigation ? this.employeeNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IFinancialTransaction extends IAuditableEntity {
    transactionId?: number;
    date?: Date;
    type?: number | undefined;
    amount?: number | undefined;
    title?: string | undefined;
    typeNavigation?: ValueGroup | undefined;
    remarks?: string | undefined;
    isDeleted?: boolean | undefined;
    employeeId?: number | undefined;
    employeeNavigation?: Employee | undefined;
}

export class OrderSMSMessage extends AuditableEntity implements IOrderSMSMessage {
    id?: number;
    orderId?: number;
    order?: Order | undefined;
    smsMessageId?: number;
    smsMessage?: SMSMessage | undefined;
    lastSent?: Date | undefined;
    sendCount?: number;
    report?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IOrderSMSMessage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.smsMessageId = _data["smsMessageId"];
            this.smsMessage = _data["smsMessage"] ? SMSMessage.fromJS(_data["smsMessage"]) : <any>undefined;
            this.lastSent = _data["lastSent"] ? new Date(_data["lastSent"].toString()) : <any>undefined;
            this.sendCount = _data["sendCount"];
            this.report = _data["report"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): OrderSMSMessage {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSMSMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["smsMessageId"] = this.smsMessageId;
        data["smsMessage"] = this.smsMessage ? this.smsMessage.toJSON() : <any>undefined;
        data["lastSent"] = this.lastSent ? this.lastSent.toISOString() : <any>undefined;
        data["sendCount"] = this.sendCount;
        data["report"] = this.report;
        data["phone"] = this.phone;
        super.toJSON(data);
        return data; 
    }
}

export interface IOrderSMSMessage extends IAuditableEntity {
    id?: number;
    orderId?: number;
    order?: Order | undefined;
    smsMessageId?: number;
    smsMessage?: SMSMessage | undefined;
    lastSent?: Date | undefined;
    sendCount?: number;
    report?: string | undefined;
    phone?: string | undefined;
}

export class SMSMessage extends AuditableEntity implements ISMSMessage {
    id?: number;
    text?: string | undefined;
    title?: string | undefined;
    orderSMSMessages?: OrderSMSMessage[] | undefined;

    constructor(data?: ISMSMessage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.title = _data["title"];
            if (Array.isArray(_data["orderSMSMessages"])) {
                this.orderSMSMessages = [] as any;
                for (let item of _data["orderSMSMessages"])
                    this.orderSMSMessages!.push(OrderSMSMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SMSMessage {
        data = typeof data === 'object' ? data : {};
        let result = new SMSMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["title"] = this.title;
        if (Array.isArray(this.orderSMSMessages)) {
            data["orderSMSMessages"] = [];
            for (let item of this.orderSMSMessages)
                data["orderSMSMessages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISMSMessage extends IAuditableEntity {
    id?: number;
    text?: string | undefined;
    title?: string | undefined;
    orderSMSMessages?: OrderSMSMessage[] | undefined;
}

/** Container for filters. */
export class FilterContainer implements IFilterContainer {
    /** Where filters. */
    where?: TreeFilter | undefined;
    /** Order filters. */
    orderBy?: OrderFilter[] | undefined;
    /** Skip number of elements. */
    skip?: number;
    /** Take number of elements. */
    take?: number;
    select?: string | undefined;
    includes?: string | undefined;

    constructor(data?: IFilterContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.where = _data["where"] ? TreeFilter.fromJS(_data["where"]) : <any>undefined;
            if (Array.isArray(_data["orderBy"])) {
                this.orderBy = [] as any;
                for (let item of _data["orderBy"])
                    this.orderBy!.push(OrderFilter.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.select = _data["select"];
            this.includes = _data["includes"];
        }
    }

    static fromJS(data: any): FilterContainer {
        data = typeof data === 'object' ? data : {};
        let result = new FilterContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["where"] = this.where ? this.where.toJSON() : <any>undefined;
        if (Array.isArray(this.orderBy)) {
            data["orderBy"] = [];
            for (let item of this.orderBy)
                data["orderBy"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["select"] = this.select;
        data["includes"] = this.includes;
        return data; 
    }
}

/** Container for filters. */
export interface IFilterContainer {
    /** Where filters. */
    where?: TreeFilter | undefined;
    /** Order filters. */
    orderBy?: OrderFilter[] | undefined;
    /** Skip number of elements. */
    skip?: number;
    /** Take number of elements. */
    take?: number;
    select?: string | undefined;
    includes?: string | undefined;
}

/** Tree filter for queryable expression. */
export class WhereFilter implements IWhereFilter {
    /** Filter field name. */
    field?: string | undefined;
    /** Type of field filtration. */
    filterType?: WhereFilterType;
    /** Value for filtering. */
    value?: any | undefined;

    constructor(data?: IWhereFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.filterType = _data["filterType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): WhereFilter {
        data = typeof data === 'object' ? data : {};
        let result = new WhereFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["filterType"] = this.filterType;
        data["value"] = this.value;
        return data; 
    }
}

/** Tree filter for queryable expression. */
export interface IWhereFilter {
    /** Filter field name. */
    field?: string | undefined;
    /** Type of field filtration. */
    filterType?: WhereFilterType;
    /** Value for filtering. */
    value?: any | undefined;
}

/** Filters with infinite nesting and boolean operations therebetween. */
export class TreeFilter extends WhereFilter implements ITreeFilter {
    /** Type of logical operator. */
    operatorType?: TreeFilterType;
    /** Operands of boolean expressions. */
    operands?: TreeFilter[] | undefined;

    constructor(data?: ITreeFilter) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.operatorType = _data["operatorType"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(TreeFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TreeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operatorType"] = this.operatorType;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** Filters with infinite nesting and boolean operations therebetween. */
export interface ITreeFilter extends IWhereFilter {
    /** Type of logical operator. */
    operatorType?: TreeFilterType;
    /** Operands of boolean expressions. */
    operands?: TreeFilter[] | undefined;
}

/** Type of operation. */
export enum TreeFilterType {
    None = 0,
    And = 1,
    Or = 2,
}

/** Type of elements comparison. */
export enum WhereFilterType {
    None = 0,
    Equal = 1,
    NotEqual = 2,
    LessThan = 3,
    GreaterThan = 4,
    LessThanOrEqual = 5,
    GreaterThanOrEqual = 6,
    Contains = 7,
    NotContains = 8,
    StartsWith = 9,
    NotStartsWith = 10,
    EndsWith = 11,
    NotEndsWith = 12,
    Any = 13,
    NotAny = 14,
    IsNull = 15,
    IsNotNull = 16,
    IsEmpty = 17,
    IsNotEmpty = 18,
    IsNullOrEmpty = 19,
    IsNotNullOrEmpty = 20,
}

/** Sort by the field. */
export class OrderFilter implements IOrderFilter {
    /** Sort field name. */
    field?: string | undefined;
    /** Sorting order. */
    order?: OrderFilterType;

    constructor(data?: IOrderFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): OrderFilter {
        data = typeof data === 'object' ? data : {};
        let result = new OrderFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["order"] = this.order;
        return data; 
    }
}

/** Sort by the field. */
export interface IOrderFilter {
    /** Sort field name. */
    field?: string | undefined;
    /** Sorting order. */
    order?: OrderFilterType;
}

/** Sorting order. */
export enum OrderFilterType {
    Asc = 0,
    Desc = 1,
}

export class DataTableRequest implements IDataTableRequest {
    draw?: number;
    start?: number;
    length?: number;
    search?: DataTableSearch | undefined;
    columns?: DataTableColumn[] | undefined;
    order?: DataTableOrder[] | undefined;
    additionalParameters?: { [key: string]: any; } | undefined;

    constructor(data?: IDataTableRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"];
            this.start = _data["start"];
            this.length = _data["length"];
            this.search = _data["search"] ? DataTableSearch.fromJS(_data["search"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(DataTableColumn.fromJS(item));
            }
            if (Array.isArray(_data["order"])) {
                this.order = [] as any;
                for (let item of _data["order"])
                    this.order!.push(DataTableOrder.fromJS(item));
            }
            if (_data["additionalParameters"]) {
                this.additionalParameters = {} as any;
                for (let key in _data["additionalParameters"]) {
                    if (_data["additionalParameters"].hasOwnProperty(key))
                        this.additionalParameters![key] = _data["additionalParameters"][key];
                }
            }
        }
    }

    static fromJS(data: any): DataTableRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw;
        data["start"] = this.start;
        data["length"] = this.length;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.order)) {
            data["order"] = [];
            for (let item of this.order)
                data["order"].push(item.toJSON());
        }
        if (this.additionalParameters) {
            data["additionalParameters"] = {};
            for (let key in this.additionalParameters) {
                if (this.additionalParameters.hasOwnProperty(key))
                    data["additionalParameters"][key] = this.additionalParameters[key];
            }
        }
        return data; 
    }
}

export interface IDataTableRequest {
    draw?: number;
    start?: number;
    length?: number;
    search?: DataTableSearch | undefined;
    columns?: DataTableColumn[] | undefined;
    order?: DataTableOrder[] | undefined;
    additionalParameters?: { [key: string]: any; } | undefined;
}

export class DataTableSearch implements IDataTableSearch {
    regex?: boolean;
    value?: string | undefined;

    constructor(data?: IDataTableSearch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regex = _data["regex"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DataTableSearch {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableSearch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regex"] = this.regex;
        data["value"] = this.value;
        return data; 
    }
}

export interface IDataTableSearch {
    regex?: boolean;
    value?: string | undefined;
}

export class DataTableColumn implements IDataTableColumn {
    data?: string | undefined;
    name?: string | undefined;
    searchable?: boolean;
    search?: DataTableSearch | undefined;
    orderable?: boolean;

    constructor(data?: IDataTableColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.name = _data["name"];
            this.searchable = _data["searchable"];
            this.search = _data["search"] ? DataTableSearch.fromJS(_data["search"]) : <any>undefined;
            this.orderable = _data["orderable"];
        }
    }

    static fromJS(data: any): DataTableColumn {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["name"] = this.name;
        data["searchable"] = this.searchable;
        data["search"] = this.search ? this.search.toJSON() : <any>undefined;
        data["orderable"] = this.orderable;
        return data; 
    }
}

export interface IDataTableColumn {
    data?: string | undefined;
    name?: string | undefined;
    searchable?: boolean;
    search?: DataTableSearch | undefined;
    orderable?: boolean;
}

export class DataTableOrder implements IDataTableOrder {
    column?: number;
    dir?: string | undefined;

    constructor(data?: IDataTableOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.dir = _data["dir"];
        }
    }

    static fromJS(data: any): DataTableOrder {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["dir"] = this.dir;
        return data; 
    }
}

export interface IDataTableOrder {
    column?: number;
    dir?: string | undefined;
}

export class AuthenticationModel implements IAuthenticationModel {
    userId?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IAuthenticationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticationModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IAuthenticationModel {
    userId?: string | undefined;
    roles?: string[] | undefined;
}

export class OrdersByCategoryQueryViewModel implements IOrdersByCategoryQueryViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;

    constructor(data?: IOrdersByCategoryQueryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): OrdersByCategoryQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrdersByCategoryQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface IOrdersByCategoryQueryViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;
}

export class OrdersRateOverTimeViewModel implements IOrdersRateOverTimeViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;

    constructor(data?: IOrdersRateOverTimeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): OrdersRateOverTimeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrdersRateOverTimeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface IOrdersRateOverTimeViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;
}

export class LowestSparesByStoreIdsQueryViewModel implements ILowestSparesByStoreIdsQueryViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;

    constructor(data?: ILowestSparesByStoreIdsQueryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): LowestSparesByStoreIdsQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LowestSparesByStoreIdsQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface ILowestSparesByStoreIdsQueryViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;
}

export class TransactionsRateOverTimeViewModel implements ITransactionsRateOverTimeViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;

    constructor(data?: ITransactionsRateOverTimeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): TransactionsRateOverTimeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsRateOverTimeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface ITransactionsRateOverTimeViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;
}

export class OrderSMSRateOverTimeViewModel implements IOrderSMSRateOverTimeViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;

    constructor(data?: IOrderSMSRateOverTimeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): OrderSMSRateOverTimeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSMSRateOverTimeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface IOrderSMSRateOverTimeViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;
}

export class AvailableSmsBalanceViewModel implements IAvailableSmsBalanceViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;

    constructor(data?: IAvailableSmsBalanceViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): AvailableSmsBalanceViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableSmsBalanceViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface IAvailableSmsBalanceViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;
}

export class AvailableSmsBalanceQuery implements IAvailableSmsBalanceQuery {

    constructor(data?: IAvailableSmsBalanceQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): AvailableSmsBalanceQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableSmsBalanceQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IAvailableSmsBalanceQuery {
}

export class TicketsByEmployeesQueryViewModel implements ITicketsByEmployeesQueryViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;

    constructor(data?: ITicketsByEmployeesQueryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketsByEmployeesQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TicketsByEmployeesQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface ITicketsByEmployeesQueryViewModel {
    labels?: string[] | undefined;
    data?: number[] | undefined;
}

export abstract class SearchQueryViewModelOfEmployeeDto implements ISearchQueryViewModelOfEmployeeDto {
    data?: EmployeeDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EmployeeDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfEmployeeDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfEmployeeDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfEmployeeDto {
    data?: EmployeeDto[] | undefined;
    totalRecords?: number;
}

export class SearchEmployeesViewModel extends SearchQueryViewModelOfEmployeeDto implements ISearchEmployeesViewModel {

    constructor(data?: ISearchEmployeesViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchEmployeesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchEmployeesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchEmployeesViewModel extends ISearchQueryViewModelOfEmployeeDto {
}

export class EmployeeDto implements IEmployeeDto {
    oid?: number;
    displayName?: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["oid"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oid"] = this.oid;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEmployeeDto {
    oid?: number;
    displayName?: string | undefined;
}

export class CreateEmployeeCommand implements ICreateEmployeeCommand {
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
    isActive?: boolean;

    constructor(data?: ICreateEmployeeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.administrator = _data["administrator"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateEmployeeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmployeeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["administrator"] = this.administrator;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ICreateEmployeeCommand {
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
    isActive?: boolean;
}

export class UpdateEmployeeCommand implements IUpdateEmployeeCommand {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
    isActive?: boolean;

    constructor(data?: IUpdateEmployeeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.administrator = _data["administrator"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateEmployeeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmployeeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["administrator"] = this.administrator;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateEmployeeCommand {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
    isActive?: boolean;
}

export abstract class SearchQueryViewModelOfSearchFinancialTransactionDto implements ISearchQueryViewModelOfSearchFinancialTransactionDto {
    data?: SearchFinancialTransactionDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfSearchFinancialTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchFinancialTransactionDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfSearchFinancialTransactionDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfSearchFinancialTransactionDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfSearchFinancialTransactionDto {
    data?: SearchFinancialTransactionDto[] | undefined;
    totalRecords?: number;
}

export class SearchFinancialTransactionsQueryViewModel extends SearchQueryViewModelOfSearchFinancialTransactionDto implements ISearchFinancialTransactionsQueryViewModel {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;

    constructor(data?: ISearchFinancialTransactionsQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchFinancialTransactionsQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFinancialTransactionsQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchFinancialTransactionsQueryViewModel extends ISearchQueryViewModelOfSearchFinancialTransactionDto {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
}

export class SearchFinancialTransactionDto implements ISearchFinancialTransactionDto {
    transactionId?: number;
    employeeId?: number | undefined;
    employeeName?: string | undefined;
    title?: string | undefined;
    type?: number | undefined;
    typeValue?: string | undefined;
    amount?: number | undefined;
    remarks?: string | undefined;
    date?: Date;
    created?: Date | undefined;

    constructor(data?: ISearchFinancialTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.typeValue = _data["typeValue"];
            this.amount = _data["amount"];
            this.remarks = _data["remarks"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchFinancialTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFinancialTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["title"] = this.title;
        data["type"] = this.type;
        data["typeValue"] = this.typeValue;
        data["amount"] = this.amount;
        data["remarks"] = this.remarks;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISearchFinancialTransactionDto {
    transactionId?: number;
    employeeId?: number | undefined;
    employeeName?: string | undefined;
    title?: string | undefined;
    type?: number | undefined;
    typeValue?: string | undefined;
    amount?: number | undefined;
    remarks?: string | undefined;
    date?: Date;
    created?: Date | undefined;
}

export abstract class SearchQuery implements ISearchQuery {
    sort?: string | undefined;
    pageIndex?: number | undefined;
    pageLength?: number | undefined;
    filter?: string | undefined;

    constructor(data?: ISearchQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sort = _data["sort"];
            this.pageIndex = _data["pageIndex"];
            this.pageLength = _data["pageLength"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): SearchQuery {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQuery' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sort"] = this.sort;
        data["pageIndex"] = this.pageIndex;
        data["pageLength"] = this.pageLength;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface ISearchQuery {
    sort?: string | undefined;
    pageIndex?: number | undefined;
    pageLength?: number | undefined;
    filter?: string | undefined;
}

export class SearchFinancialTransactionsQuery extends SearchQuery implements ISearchFinancialTransactionsQuery {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;

    constructor(data?: ISearchFinancialTransactionsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchFinancialTransactionsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFinancialTransactionsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchFinancialTransactionsQuery extends ISearchQuery {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
}

export class FinancialTransactionsStatisticsQueryViewModel implements IFinancialTransactionsStatisticsQueryViewModel {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    totalIncomes?: number;
    totalExpenses?: number;
    savings?: number;

    constructor(data?: IFinancialTransactionsStatisticsQueryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.totalIncomes = _data["totalIncomes"];
            this.totalExpenses = _data["totalExpenses"];
            this.savings = _data["savings"];
        }
    }

    static fromJS(data: any): FinancialTransactionsStatisticsQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialTransactionsStatisticsQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["totalIncomes"] = this.totalIncomes;
        data["totalExpenses"] = this.totalExpenses;
        data["savings"] = this.savings;
        return data; 
    }
}

export interface IFinancialTransactionsStatisticsQueryViewModel {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    totalIncomes?: number;
    totalExpenses?: number;
    savings?: number;
}

export class FinancialTransactionsStatisticsQuery implements IFinancialTransactionsStatisticsQuery {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;

    constructor(data?: IFinancialTransactionsStatisticsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FinancialTransactionsStatisticsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialTransactionsStatisticsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IFinancialTransactionsStatisticsQuery {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
}

export class CreateFinancialTransactionCommand implements ICreateFinancialTransactionCommand {
    type?: number;
    amount?: number;
    title?: string | undefined;
    remarks?: string | undefined;
    date?: Date;
    employeeId?: number | undefined;

    constructor(data?: ICreateFinancialTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.title = _data["title"];
            this.remarks = _data["remarks"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): CreateFinancialTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFinancialTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["title"] = this.title;
        data["remarks"] = this.remarks;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface ICreateFinancialTransactionCommand {
    type?: number;
    amount?: number;
    title?: string | undefined;
    remarks?: string | undefined;
    date?: Date;
    employeeId?: number | undefined;
}

export class UpdateFinancialTransactionCommand implements IUpdateFinancialTransactionCommand {
    transactionId?: number;
    type?: number;
    amount?: number;
    title?: string | undefined;
    remarks?: string | undefined;
    date?: Date;
    employeeId?: number;

    constructor(data?: IUpdateFinancialTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.title = _data["title"];
            this.remarks = _data["remarks"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): UpdateFinancialTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFinancialTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["title"] = this.title;
        data["remarks"] = this.remarks;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IUpdateFinancialTransactionCommand {
    transactionId?: number;
    type?: number;
    amount?: number;
    title?: string | undefined;
    remarks?: string | undefined;
    date?: Date;
    employeeId?: number;
}

export class ExportFinancialTransactionQueryViewModel implements IExportFinancialTransactionQueryViewModel {
    data?: SearchFinancialTransactionDto[] | undefined;

    constructor(data?: IExportFinancialTransactionQueryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchFinancialTransactionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportFinancialTransactionQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExportFinancialTransactionQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExportFinancialTransactionQueryViewModel {
    data?: SearchFinancialTransactionDto[] | undefined;
}

export class ExportFinancialTransactionQuery implements IExportFinancialTransactionQuery {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    withdrawal?: boolean;
    deposit?: boolean;

    constructor(data?: IExportFinancialTransactionQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.withdrawal = _data["withdrawal"];
            this.deposit = _data["deposit"];
        }
    }

    static fromJS(data: any): ExportFinancialTransactionQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ExportFinancialTransactionQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["withdrawal"] = this.withdrawal;
        data["deposit"] = this.deposit;
        return data; 
    }
}

export interface IExportFinancialTransactionQuery {
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    withdrawal?: boolean;
    deposit?: boolean;
}

export abstract class SearchQueryViewModelOfSearchInventoryDto implements ISearchQueryViewModelOfSearchInventoryDto {
    data?: SearchInventoryDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfSearchInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchInventoryDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfSearchInventoryDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfSearchInventoryDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfSearchInventoryDto {
    data?: SearchInventoryDto[] | undefined;
    totalRecords?: number;
}

export class SearchInventoriesQueryViewModel extends SearchQueryViewModelOfSearchInventoryDto implements ISearchInventoriesQueryViewModel {

    constructor(data?: ISearchInventoriesQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchInventoriesQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInventoriesQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchInventoriesQueryViewModel extends ISearchQueryViewModelOfSearchInventoryDto {
}

export class SearchInventoryDto implements ISearchInventoryDto {
    inventoryId?: number;
    storeId?: number;
    storeTitle?: string | undefined;
    sparePartBarcode?: string | undefined;
    spareItemId?: number;
    sparePartTitle?: string | undefined;
    openingBalance?: number;
    currentBalance?: number;

    constructor(data?: ISearchInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryId = _data["inventoryId"];
            this.storeId = _data["storeId"];
            this.storeTitle = _data["storeTitle"];
            this.sparePartBarcode = _data["sparePartBarcode"];
            this.spareItemId = _data["spareItemId"];
            this.sparePartTitle = _data["sparePartTitle"];
            this.openingBalance = _data["openingBalance"];
            this.currentBalance = _data["currentBalance"];
        }
    }

    static fromJS(data: any): SearchInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryId"] = this.inventoryId;
        data["storeId"] = this.storeId;
        data["storeTitle"] = this.storeTitle;
        data["sparePartBarcode"] = this.sparePartBarcode;
        data["spareItemId"] = this.spareItemId;
        data["sparePartTitle"] = this.sparePartTitle;
        data["openingBalance"] = this.openingBalance;
        data["currentBalance"] = this.currentBalance;
        return data; 
    }
}

export interface ISearchInventoryDto {
    inventoryId?: number;
    storeId?: number;
    storeTitle?: string | undefined;
    sparePartBarcode?: string | undefined;
    spareItemId?: number;
    sparePartTitle?: string | undefined;
    openingBalance?: number;
    currentBalance?: number;
}

export class SearchInventoriesQuery extends SearchQuery implements ISearchInventoriesQuery {
    storeId?: number | undefined;
    sparePartId?: number | undefined;

    constructor(data?: ISearchInventoriesQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.storeId = _data["storeId"];
            this.sparePartId = _data["sparePartId"];
        }
    }

    static fromJS(data: any): SearchInventoriesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInventoriesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["sparePartId"] = this.sparePartId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchInventoriesQuery extends ISearchQuery {
    storeId?: number | undefined;
    sparePartId?: number | undefined;
}

export class CreateInventoryCommand implements ICreateInventoryCommand {

    constructor(data?: ICreateInventoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CreateInventoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ICreateInventoryCommand {
}

export class UpdateInventoryCommand implements IUpdateInventoryCommand {
    id?: number;

    constructor(data?: IUpdateInventoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateInventoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInventoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateInventoryCommand {
    id?: number;
}

export abstract class SearchQueryViewModelOfSearchITransactionDto implements ISearchQueryViewModelOfSearchITransactionDto {
    data?: SearchITransactionDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfSearchITransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchITransactionDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfSearchITransactionDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfSearchITransactionDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfSearchITransactionDto {
    data?: SearchITransactionDto[] | undefined;
    totalRecords?: number;
}

export class SearchITransactionsQueryViewModel extends SearchQueryViewModelOfSearchITransactionDto implements ISearchITransactionsQueryViewModel {

    constructor(data?: ISearchITransactionsQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchITransactionsQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchITransactionsQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchITransactionsQueryViewModel extends ISearchQueryViewModelOfSearchITransactionDto {
}

export class SearchITransactionDto implements ISearchITransactionDto {
    transactionId?: number;
    inventoryId?: number;
    storeTitle?: string | undefined;
    storeAdministrator?: string | undefined;
    sparePartTitle?: string | undefined;
    sparePartBarcode?: string | undefined;
    type?: number | undefined;
    typeValue?: string | undefined;
    amount?: number | undefined;
    description?: string | undefined;
    created?: Date | undefined;
    referenceType?: number | undefined;
    referenceTypeValue?: string | undefined;
    referenceId?: string | undefined;

    constructor(data?: ISearchITransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.inventoryId = _data["inventoryId"];
            this.storeTitle = _data["storeTitle"];
            this.storeAdministrator = _data["storeAdministrator"];
            this.sparePartTitle = _data["sparePartTitle"];
            this.sparePartBarcode = _data["sparePartBarcode"];
            this.type = _data["type"];
            this.typeValue = _data["typeValue"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.referenceType = _data["referenceType"];
            this.referenceTypeValue = _data["referenceTypeValue"];
            this.referenceId = _data["referenceId"];
        }
    }

    static fromJS(data: any): SearchITransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchITransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["inventoryId"] = this.inventoryId;
        data["storeTitle"] = this.storeTitle;
        data["storeAdministrator"] = this.storeAdministrator;
        data["sparePartTitle"] = this.sparePartTitle;
        data["sparePartBarcode"] = this.sparePartBarcode;
        data["type"] = this.type;
        data["typeValue"] = this.typeValue;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["referenceType"] = this.referenceType;
        data["referenceTypeValue"] = this.referenceTypeValue;
        data["referenceId"] = this.referenceId;
        return data; 
    }
}

export interface ISearchITransactionDto {
    transactionId?: number;
    inventoryId?: number;
    storeTitle?: string | undefined;
    storeAdministrator?: string | undefined;
    sparePartTitle?: string | undefined;
    sparePartBarcode?: string | undefined;
    type?: number | undefined;
    typeValue?: string | undefined;
    amount?: number | undefined;
    description?: string | undefined;
    created?: Date | undefined;
    referenceType?: number | undefined;
    referenceTypeValue?: string | undefined;
    referenceId?: string | undefined;
}

export class SearchITransactionsQuery extends SearchQuery implements ISearchITransactionsQuery {
    inventoryId?: number | undefined;

    constructor(data?: ISearchITransactionsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.inventoryId = _data["inventoryId"];
        }
    }

    static fromJS(data: any): SearchITransactionsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchITransactionsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryId"] = this.inventoryId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchITransactionsQuery extends ISearchQuery {
    inventoryId?: number | undefined;
}

export class CreateInventoryTransactionCommand implements ICreateInventoryTransactionCommand {
    inventoryId?: number;
    type?: number | undefined;
    amount?: number | undefined;
    description?: string | undefined;
    storeId?: number | undefined;
    referenceType?: number | undefined;
    referenceId?: string | undefined;

    constructor(data?: ICreateInventoryTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryId = _data["inventoryId"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.storeId = _data["storeId"];
            this.referenceType = _data["referenceType"];
            this.referenceId = _data["referenceId"];
        }
    }

    static fromJS(data: any): CreateInventoryTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryId"] = this.inventoryId;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["storeId"] = this.storeId;
        data["referenceType"] = this.referenceType;
        data["referenceId"] = this.referenceId;
        return data; 
    }
}

export interface ICreateInventoryTransactionCommand {
    inventoryId?: number;
    type?: number | undefined;
    amount?: number | undefined;
    description?: string | undefined;
    storeId?: number | undefined;
    referenceType?: number | undefined;
    referenceId?: string | undefined;
}

export class UpdateInventoryTransactionCommand implements IUpdateInventoryTransactionCommand {
    id?: number;

    constructor(data?: IUpdateInventoryTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateInventoryTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInventoryTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateInventoryTransactionCommand {
    id?: number;
}

export abstract class SearchQueryViewModelOfSearchOrderSMSMessageDto implements ISearchQueryViewModelOfSearchOrderSMSMessageDto {
    data?: SearchOrderSMSMessageDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfSearchOrderSMSMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchOrderSMSMessageDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfSearchOrderSMSMessageDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfSearchOrderSMSMessageDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfSearchOrderSMSMessageDto {
    data?: SearchOrderSMSMessageDto[] | undefined;
    totalRecords?: number;
}

export class SearchOrderSMSMessagesQueryViewModel extends SearchQueryViewModelOfSearchOrderSMSMessageDto implements ISearchOrderSMSMessagesQueryViewModel {

    constructor(data?: ISearchOrderSMSMessagesQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchOrderSMSMessagesQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOrderSMSMessagesQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchOrderSMSMessagesQueryViewModel extends ISearchQueryViewModelOfSearchOrderSMSMessageDto {
}

export class SearchOrderSMSMessageDto implements ISearchOrderSMSMessageDto {
    id?: number;
    orderId?: number;
    customer?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    smsMessageId?: number;
    lastSent?: Date | undefined;
    sendCount?: number;
    report?: string | undefined;
    phone?: string | undefined;

    constructor(data?: ISearchOrderSMSMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderId = _data["orderId"];
            this.customer = _data["customer"];
            this.primaryPhone = _data["primaryPhone"];
            this.secondaryPhone = _data["secondaryPhone"];
            this.smsMessageId = _data["smsMessageId"];
            this.lastSent = _data["lastSent"] ? new Date(_data["lastSent"].toString()) : <any>undefined;
            this.sendCount = _data["sendCount"];
            this.report = _data["report"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): SearchOrderSMSMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOrderSMSMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderId"] = this.orderId;
        data["customer"] = this.customer;
        data["primaryPhone"] = this.primaryPhone;
        data["secondaryPhone"] = this.secondaryPhone;
        data["smsMessageId"] = this.smsMessageId;
        data["lastSent"] = this.lastSent ? this.lastSent.toISOString() : <any>undefined;
        data["sendCount"] = this.sendCount;
        data["report"] = this.report;
        data["phone"] = this.phone;
        return data; 
    }
}

export interface ISearchOrderSMSMessageDto {
    id?: number;
    orderId?: number;
    customer?: string | undefined;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
    smsMessageId?: number;
    lastSent?: Date | undefined;
    sendCount?: number;
    report?: string | undefined;
    phone?: string | undefined;
}

export class SearchOrderSMSMessagesQuery extends SearchQuery implements ISearchOrderSMSMessagesQuery {
    orderId?: number | undefined;
    smsMessageId?: number | undefined;

    constructor(data?: ISearchOrderSMSMessagesQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.orderId = _data["orderId"];
            this.smsMessageId = _data["smsMessageId"];
        }
    }

    static fromJS(data: any): SearchOrderSMSMessagesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOrderSMSMessagesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["smsMessageId"] = this.smsMessageId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchOrderSMSMessagesQuery extends ISearchQuery {
    orderId?: number | undefined;
    smsMessageId?: number | undefined;
}

export class AddOrdersForSMSMessageCommand implements IAddOrdersForSMSMessageCommand {
    smsMessageId?: number;
    ordersIds?: string | undefined;

    constructor(data?: IAddOrdersForSMSMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smsMessageId = _data["smsMessageId"];
            this.ordersIds = _data["ordersIds"];
        }
    }

    static fromJS(data: any): AddOrdersForSMSMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrdersForSMSMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smsMessageId"] = this.smsMessageId;
        data["ordersIds"] = this.ordersIds;
        return data; 
    }
}

export interface IAddOrdersForSMSMessageCommand {
    smsMessageId?: number;
    ordersIds?: string | undefined;
}

export class UpdateOrderPhonesCommand implements IUpdateOrderPhonesCommand {
    orderId?: number;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;

    constructor(data?: IUpdateOrderPhonesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.primaryPhone = _data["primaryPhone"];
            this.secondaryPhone = _data["secondaryPhone"];
        }
    }

    static fromJS(data: any): UpdateOrderPhonesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderPhonesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["primaryPhone"] = this.primaryPhone;
        data["secondaryPhone"] = this.secondaryPhone;
        return data; 
    }
}

export interface IUpdateOrderPhonesCommand {
    orderId?: number;
    primaryPhone?: string | undefined;
    secondaryPhone?: string | undefined;
}

export abstract class SearchQueryViewModelOfSearchSMSMessageDto implements ISearchQueryViewModelOfSearchSMSMessageDto {
    data?: SearchSMSMessageDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfSearchSMSMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchSMSMessageDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfSearchSMSMessageDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfSearchSMSMessageDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfSearchSMSMessageDto {
    data?: SearchSMSMessageDto[] | undefined;
    totalRecords?: number;
}

export class SearchSMSMessagesViewModel extends SearchQueryViewModelOfSearchSMSMessageDto implements ISearchSMSMessagesViewModel {

    constructor(data?: ISearchSMSMessagesViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchSMSMessagesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSMSMessagesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchSMSMessagesViewModel extends ISearchQueryViewModelOfSearchSMSMessageDto {
}

export class SearchSMSMessageDto implements ISearchSMSMessageDto {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
    ordersCount?: number;
    created?: Date | undefined;

    constructor(data?: ISearchSMSMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.text = _data["text"];
            this.ordersCount = _data["ordersCount"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchSMSMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSMSMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["text"] = this.text;
        data["ordersCount"] = this.ordersCount;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISearchSMSMessageDto {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
    ordersCount?: number;
    created?: Date | undefined;
}

export class SearchSMSMessagesQuery extends SearchQuery implements ISearchSMSMessagesQuery {

    constructor(data?: ISearchSMSMessagesQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchSMSMessagesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSMSMessagesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchSMSMessagesQuery extends ISearchQuery {
}

export class SMSMessageDto implements ISMSMessageDto {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;

    constructor(data?: ISMSMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): SMSMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new SMSMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["text"] = this.text;
        return data; 
    }
}

export interface ISMSMessageDto {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
}

export class SendSMSMessageCommand implements ISendSMSMessageCommand {
    orderSMSMessageId?: number;
    useSecondary?: boolean;

    constructor(data?: ISendSMSMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderSMSMessageId = _data["orderSMSMessageId"];
            this.useSecondary = _data["useSecondary"];
        }
    }

    static fromJS(data: any): SendSMSMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendSMSMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderSMSMessageId"] = this.orderSMSMessageId;
        data["useSecondary"] = this.useSecondary;
        return data; 
    }
}

export interface ISendSMSMessageCommand {
    orderSMSMessageId?: number;
    useSecondary?: boolean;
}

export class CreateSMSMessageCommand implements ICreateSMSMessageCommand {
    title?: string | undefined;
    text?: string | undefined;

    constructor(data?: ICreateSMSMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): CreateSMSMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSMSMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["text"] = this.text;
        return data; 
    }
}

export interface ICreateSMSMessageCommand {
    title?: string | undefined;
    text?: string | undefined;
}

export class UpdateSMSMessageCommand implements IUpdateSMSMessageCommand {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;

    constructor(data?: IUpdateSMSMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): UpdateSMSMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSMSMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["text"] = this.text;
        return data; 
    }
}

export interface IUpdateSMSMessageCommand {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
}

export abstract class SearchQueryViewModelOfSearchSparePartDto implements ISearchQueryViewModelOfSearchSparePartDto {
    data?: SearchSparePartDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfSearchSparePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchSparePartDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfSearchSparePartDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfSearchSparePartDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfSearchSparePartDto {
    data?: SearchSparePartDto[] | undefined;
    totalRecords?: number;
}

export class SearchSparePartsViewModel extends SearchQueryViewModelOfSearchSparePartDto implements ISearchSparePartsViewModel {

    constructor(data?: ISearchSparePartsViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchSparePartsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSparePartsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchSparePartsViewModel extends ISearchQueryViewModelOfSearchSparePartDto {
}

export class SearchSparePartDto implements ISearchSparePartDto {
    sparePartId?: number;
    title?: string | undefined;
    barcode?: string | undefined;
    category?: number | undefined;
    description?: string | undefined;
    totalBalance?: number;

    constructor(data?: ISearchSparePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sparePartId = _data["sparePartId"];
            this.title = _data["title"];
            this.barcode = _data["barcode"];
            this.category = _data["category"];
            this.description = _data["description"];
            this.totalBalance = _data["totalBalance"];
        }
    }

    static fromJS(data: any): SearchSparePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSparePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sparePartId"] = this.sparePartId;
        data["title"] = this.title;
        data["barcode"] = this.barcode;
        data["category"] = this.category;
        data["description"] = this.description;
        data["totalBalance"] = this.totalBalance;
        return data; 
    }
}

export interface ISearchSparePartDto {
    sparePartId?: number;
    title?: string | undefined;
    barcode?: string | undefined;
    category?: number | undefined;
    description?: string | undefined;
    totalBalance?: number;
}

export class SearchSparePartsQuery extends SearchQuery implements ISearchSparePartsQuery {

    constructor(data?: ISearchSparePartsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchSparePartsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSparePartsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchSparePartsQuery extends ISearchQuery {
}

export class SparePartDto implements ISparePartDto {
    sparePartId?: number;
    title?: string | undefined;
    barcode?: string | undefined;
    description?: string | undefined;

    constructor(data?: ISparePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sparePartId = _data["sparePartId"];
            this.title = _data["title"];
            this.barcode = _data["barcode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SparePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new SparePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sparePartId"] = this.sparePartId;
        data["title"] = this.title;
        data["barcode"] = this.barcode;
        data["description"] = this.description;
        return data; 
    }
}

export interface ISparePartDto {
    sparePartId?: number;
    title?: string | undefined;
    barcode?: string | undefined;
    description?: string | undefined;
}

export class CreateSparePartCommand implements ICreateSparePartCommand {
    title?: string | undefined;
    barcode?: string | undefined;
    description?: string | undefined;
    storeId?: number;
    openingBalance?: number;

    constructor(data?: ICreateSparePartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.barcode = _data["barcode"];
            this.description = _data["description"];
            this.storeId = _data["storeId"];
            this.openingBalance = _data["openingBalance"];
        }
    }

    static fromJS(data: any): CreateSparePartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSparePartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["barcode"] = this.barcode;
        data["description"] = this.description;
        data["storeId"] = this.storeId;
        data["openingBalance"] = this.openingBalance;
        return data; 
    }
}

export interface ICreateSparePartCommand {
    title?: string | undefined;
    barcode?: string | undefined;
    description?: string | undefined;
    storeId?: number;
    openingBalance?: number;
}

export class UpdateSparePartCommand implements IUpdateSparePartCommand {
    sparePartId?: number;
    barcode?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateSparePartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sparePartId = _data["sparePartId"];
            this.barcode = _data["barcode"];
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateSparePartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSparePartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sparePartId"] = this.sparePartId;
        data["barcode"] = this.barcode;
        data["title"] = this.title;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateSparePartCommand {
    sparePartId?: number;
    barcode?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
}

export abstract class SearchQueryViewModelOfSearchStoreDto implements ISearchQueryViewModelOfSearchStoreDto {
    data?: SearchStoreDto[] | undefined;
    totalRecords?: number;

    constructor(data?: ISearchQueryViewModelOfSearchStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SearchStoreDto.fromJS(item));
            }
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): SearchQueryViewModelOfSearchStoreDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SearchQueryViewModelOfSearchStoreDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface ISearchQueryViewModelOfSearchStoreDto {
    data?: SearchStoreDto[] | undefined;
    totalRecords?: number;
}

export class SearchStoresQueryViewModel extends SearchQueryViewModelOfSearchStoreDto implements ISearchStoresQueryViewModel {

    constructor(data?: ISearchStoresQueryViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchStoresQueryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStoresQueryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchStoresQueryViewModel extends ISearchQueryViewModelOfSearchStoreDto {
}

export class SearchStoreDto implements ISearchStoreDto {
    storeId?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: EmployeeDto | undefined;
    totalBalance?: number;

    constructor(data?: ISearchStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.administrator = _data["administrator"] ? EmployeeDto.fromJS(_data["administrator"]) : <any>undefined;
            this.totalBalance = _data["totalBalance"];
        }
    }

    static fromJS(data: any): SearchStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["administrator"] = this.administrator ? this.administrator.toJSON() : <any>undefined;
        data["totalBalance"] = this.totalBalance;
        return data; 
    }
}

export interface ISearchStoreDto {
    storeId?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: EmployeeDto | undefined;
    totalBalance?: number;
}

export class SearchStoresQuery extends SearchQuery implements ISearchStoresQuery {

    constructor(data?: ISearchStoresQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SearchStoresQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStoresQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchStoresQuery extends ISearchQuery {
}

export class CreateStoreCommand implements ICreateStoreCommand {
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;

    constructor(data?: ICreateStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.administrator = _data["administrator"];
        }
    }

    static fromJS(data: any): CreateStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["administrator"] = this.administrator;
        return data; 
    }
}

export interface ICreateStoreCommand {
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
}

export class UpdateStoreCommand implements IUpdateStoreCommand {
    storeId?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;

    constructor(data?: IUpdateStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.administrator = _data["administrator"];
        }
    }

    static fromJS(data: any): UpdateStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["administrator"] = this.administrator;
        return data; 
    }
}

export interface IUpdateStoreCommand {
    storeId?: number;
    title?: string | undefined;
    description?: string | undefined;
    administrator?: number;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data; 
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class ValueGroupDto implements IValueGroupDto {
    valueGroupId?: number;
    value?: string | undefined;
    group?: string | undefined;

    constructor(data?: IValueGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valueGroupId = _data["valueGroupId"];
            this.value = _data["value"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any): ValueGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueGroupId"] = this.valueGroupId;
        data["value"] = this.value;
        data["group"] = this.group;
        return data; 
    }
}

export interface IValueGroupDto {
    valueGroupId?: number;
    value?: string | undefined;
    group?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}